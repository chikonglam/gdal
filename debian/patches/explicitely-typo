Description: Fix 'explicitely' typo, replace with 'explicitly'.
Author: Bas Couwenberg <sebastic@xs4all.nl>
Forwarded: http://trac.osgeo.org/gdal/ticket/5995

--- a/NEWS
+++ b/NEWS
@@ -57,7 +57,7 @@ Build(Unix):
  * Make sure $(GDAL_INCLUDE) is first to avoid being confused by GDAL headers of a previous version elsewhere in the include path (#5664)
  * Always use stat rather than stat64 for Mac OSX in AC_UNIX_STDIO_64. (#5780, #5414).
  * Add support for ECW SDK 5.1 (#5390)
- * Do not enable Python bindings if PYTHON env variable is set without --with-python being explicitely specified (#5956)
+ * Do not enable Python bindings if PYTHON env variable is set without --with-python being explicitly specified (#5956)
 
 Build(Windows):
  * PDF: fix compilation issue with Visual Studio 2012 (#5744)
@@ -1356,7 +1356,7 @@ Core:
  * OGR SQL: more stricter checks
  * OGR SQL: make parsing error report a usefull hint where the syntax error occured
  * OGR SQL: fix thread-safety of swq_op_registrar::GetOperator() (#5196)
- * OGR SQL: support not explicitely specifying AS keyword for aliasing a column spec
+ * OGR SQL: support not explicitly specifying AS keyword for aliasing a column spec
  * OGR SQL: don't call CONCAT(a_column ...) or SUBSTR(a_column ...) as a_column
  * OGR SQL: validate that arguments of MAX, MIN, AVG, SUM, COUNT are columns and not any expression since this is not supported
  * OGR SQL: make AVG field definition a OFTReal
--- a/frmts/ecw/ecwasyncreader.cpp
+++ b/frmts/ecw/ecwasyncreader.cpp
@@ -281,7 +281,7 @@ NCSEcwReadStatus ECWAsyncReader::Refresh
             poReader->bComplete = TRUE;
     }
 
-    /* Call CPLCleanupTLS explicitely since this thread isn't managed */
+    /* Call CPLCleanupTLS explicitly since this thread isn't managed */
     /* by CPL. This will free the ressources taken by the above CPLDebug */
     if( poReader->bComplete )
         CPLCleanupTLS();
--- a/gcore/gdaldataset.cpp
+++ b/gcore/gdaldataset.cpp
@@ -3535,7 +3535,7 @@ OGRLayerH GDALDatasetCopyLayer( GDALData
  @param hSpatialFilter geometry which represents a spatial filter. Can be NULL.
  @param pszDialect allows control of the statement dialect. If set to NULL, the
 OGR SQL engine will be used, except for RDBMS drivers that will use their dedicated SQL engine,
-unless OGRSQL is explicitely passed as the dialect. Starting with OGR 1.10, the SQLITE dialect
+unless OGRSQL is explicitly passed as the dialect. Starting with OGR 1.10, the SQLITE dialect
 can also be used.
 
  @return an OGRLayer containing the results of the query.  Deallocate with
@@ -4893,7 +4893,7 @@ OGRErr GDALDataset::ProcessSQLAlterTable
  @param poSpatialFilter geometry which represents a spatial filter. Can be NULL.
  @param pszDialect allows control of the statement dialect. If set to NULL, the
 OGR SQL engine will be used, except for RDBMS drivers that will use their dedicated SQL engine,
-unless OGRSQL is explicitely passed as the dialect. Starting with OGR 1.10, the SQLITE dialect
+unless OGRSQL is explicitly passed as the dialect. Starting with OGR 1.10, the SQLITE dialect
 can also be used.
 
  @return an OGRLayer containing the results of the query.  Deallocate with
@@ -5559,7 +5559,7 @@ int GDALDataset::TestCapability( CPL_UNU
  
  By default, when bForce is set to FALSE, only "efficient" transactions will be
  attempted. Some drivers may offer an emulation of transactions, but sometimes
- with significant overhead, in which case the user must explicitely allow for such
+ with significant overhead, in which case the user must explicitly allow for such
  an emulation by setting bForce to TRUE. Drivers that offer emulated transactions
  should advertize the ODsCEmulatedTransactions capability (and not ODsCTransactions).
  
@@ -5609,7 +5609,7 @@ OGRErr GDALDataset::StartTransaction(CPL
 
  By default, when bForce is set to FALSE, only "efficient" transactions will be
  attempted. Some drivers may offer an emulation of transactions, but sometimes
- with significant overhead, in which case the user must explicitely allow for such
+ with significant overhead, in which case the user must explicitly allow for such
  an emulation by setting bForce to TRUE. Drivers that offer emulated transactions
  should advertize the ODsCEmulatedTransactions capability (and not ODsCTransactions).
 
--- a/ogr/ogrsf_frmts/sqlite/ogr_sqlite.h
+++ b/ogr/ogrsf_frmts/sqlite/ogr_sqlite.h
@@ -675,7 +675,7 @@ class OGRSQLiteBaseDataSource : public G
 #endif
 
     VSILFILE*           fpMainFile; /* Set by the VFS layer when it opens the DB */
-                                    /* Must *NOT* be closed by the datasource explicitely. */
+                                    /* Must *NOT* be closed by the datasource explicitly. */
 
     int                 OpenOrCreateDB(int flags, int bRegisterOGR2SQLiteExtensions);
     int                 SetSynchronous();
--- a/ogr/ogrsf_frmts/vrt/drv_vrt.html
+++ b/ogr/ogrsf_frmts/vrt/drv_vrt.html
@@ -160,7 +160,7 @@ whether the geometry field is nullable.
 </p>
 <p>
 When several geometry fields are used, the following child elements of <b>GeometryField</b>
-can be defined to explicitely set the geometry type, SRS, source region, or extent.
+can be defined to explicitly set the geometry type, SRS, source region, or extent.
 <ul>
 <li><b>GeometryType</b> (optional) : same syntax as OGRVRTLayer-level <b>GeometryType</b>.</li>
 <li><b>SRS</b> (optional) : same syntax as OGRVRTLayer-level <b>LayerSRS</b> (note SRS vs LayerSRS)</li>
--- a/apps/gdal_grid.cpp
+++ b/apps/gdal_grid.cpp
@@ -610,7 +610,7 @@ int main( int argc, char ** argv )
 {
     GDALDriverH     hDriver;
     const char      *pszSource=NULL, *pszDest=NULL, *pszFormat = "GTiff";
-    int             bFormatExplicitelySet = FALSE;
+    int             bFormatExplicitlySet = FALSE;
     char            **papszLayers = NULL;
     const char      *pszBurnAttribute = NULL;
     double          dfIncreaseBurnValue = 0.0;
@@ -665,7 +665,7 @@ int main( int argc, char ** argv )
         {
             CHECK_HAS_ENOUGH_ADDITIONAL_ARGS(1);
             pszFormat = argv[++i];
-            bFormatExplicitelySet = TRUE;
+            bFormatExplicitlySet = TRUE;
         }
 
         else if( EQUAL(argv[i],"-q") || EQUAL(argv[i],"-quiet") )
@@ -1021,7 +1021,7 @@ int main( int argc, char ** argv )
     if ( nYSize == 0 )
         nYSize = 256;
 
-    if (!bQuiet && !bFormatExplicitelySet)
+    if (!bQuiet && !bFormatExplicitlySet)
         CheckExtensionConsistency(pszDest, pszFormat);
 
     hDstDS = GDALCreate( hDriver, pszDest, nXSize, nYSize, nBands,
--- a/ogr/ogrsf_frmts/filegdb/FGdbDatasource.cpp
+++ b/ogr/ogrsf_frmts/filegdb/FGdbDatasource.cpp
@@ -487,7 +487,7 @@ OGRLayer * FGdbDataSource::ExecuteSQL( c
         CPLDebug("FGDB", "Support for SELECT is known to be partially "
                          "non-compliant with FileGDB SDK API v1.2.\n"
                          "So for now, we use default OGR SQL engine. "
-                         "Explicitely specify -dialect FileGDB\n"
+                         "Explicitly specify -dialect FileGDB\n"
                          "to use the SQL engine from the FileGDB SDK API");
         return OGRDataSource::ExecuteSQL( pszSQLCommand,
                                         poSpatialFilter,
--- a/MIGRATION_GUIDE.TXT
+++ b/MIGRATION_GUIDE.TXT
@@ -141,7 +141,7 @@ Behaviour changes:
 
   * The PG and SQLite drivers could accept apparently nested calls to StartTransaction()
     (at the layer level). This is no longer possible since they are now redirected
-    to dataset transactions, that explicitely do not support it.
+    to dataset transactions, that explicitly do not support it.
 
 H) RFC 55: Refined SetFeature() and DeleteFeature() semantics
 
--- a/apps/ogrlineref.cpp
+++ b/apps/ogrlineref.cpp
@@ -1223,7 +1223,7 @@ int main( int nArgc, char ** papszArgv )
         else if( EQUAL(papszArgv[iArg],"-f") )
         {
             CHECK_HAS_ENOUGH_ADDITIONAL_ARGS(1);
-            //bFormatExplicitelySet = TRUE;
+            //bFormatExplicitlySet = TRUE;
             pszFormat = papszArgv[++iArg];
         }
         else if( EQUAL(papszArgv[iArg],"-dsco") )
--- a/configure
+++ b/configure
@@ -17463,7 +17463,7 @@ $as_echo "no" >&6; }
              if test "$with_sse" = "yes"; then
                echo "Caution: the generated binaries will not run on this system."
              else
-               echo "Disabling SSE as it is not explicitely required"
+               echo "Disabling SSE as it is not explicitly required"
                HAVE_SSE_AT_COMPILE_TIME=""
                SSEFLAGS=""
              fi
@@ -17537,7 +17537,7 @@ $as_echo "no" >&6; }
              if test "$with_avx" = "yes"; then
                echo "Caution: the generated binaries will not run on this system."
              else
-               echo "Disabling AVX as it is not explicitely required"
+               echo "Disabling AVX as it is not explicitly required"
                AVXFLAGS=""
                HAVE_AVX_AT_COMPILE_TIME=""
              fi
--- a/configure.in
+++ b/configure.in
@@ -257,7 +257,7 @@ if test "$with_sse" = "yes" -o "$with_ss
 
     dnl On Solaris, the presence of SSE instructions is flagged in the binary
     dnl and prevent it to run on non SSE hardware even if the instructions are
-    dnl not executed. So if the user did not explicitely requires SSE, test that
+    dnl not executed. So if the user did not explicitly requires SSE, test that
     dnl we can run SSE binaries
     if test "$HAVE_SSE_AT_COMPILE_TIME" = "yes"; then
        case $host_os in
@@ -270,7 +270,7 @@ if test "$with_sse" = "yes" -o "$with_ss
              if test "$with_sse" = "yes"; then
                echo "Caution: the generated binaries will not run on this system."
              else
-               echo "Disabling SSE as it is not explicitely required"
+               echo "Disabling SSE as it is not explicitly required"
                HAVE_SSE_AT_COMPILE_TIME=""
                SSEFLAGS=""
              fi
@@ -324,7 +324,7 @@ if test "$with_avx" = "yes" -o "$with_av
 
     dnl On Solaris, the presence of AVX instructions is flagged in the binary
     dnl and prevent it to run on non AVX hardware even if the instructions are
-    dnl not executed. So if the user did not explicitely requires AVX, test that
+    dnl not executed. So if the user did not explicitly requires AVX, test that
     dnl we can run AVX binaries
     if test "$HAVE_AVX_AT_COMPILE_TIME" = "yes"; then
        case $host_os in
@@ -337,7 +337,7 @@ if test "$with_avx" = "yes" -o "$with_av
              if test "$with_avx" = "yes"; then
                echo "Caution: the generated binaries will not run on this system."
              else
-               echo "Disabling AVX as it is not explicitely required"
+               echo "Disabling AVX as it is not explicitly required"
                AVXFLAGS=""
                HAVE_AVX_AT_COMPILE_TIME=""
              fi
--- a/frmts/ecw/ecwdataset.cpp
+++ b/frmts/ecw/ecwdataset.cpp
@@ -1010,7 +1010,7 @@ ECWDataset::~ECWDataset()
     //
     // We also have an issue with ECW SDK 5.0 and ECW files on Linux when
     // running a multi-threaded test under Java if there's still an ECW dataset
-    // not explicitely closed at process termination.
+    // not explicitly closed at process termination.
     /*  #0  0x00007fffb26e7a80 in NCSAtomicAdd64 () from /home/even/ecwjp2_sdk/redistributable/x64/libNCSEcw.so
         #1  0x00007fffb2aa7684 in NCS::SDK::CBuffer2D::Free() () from /home/even/ecwjp2_sdk/redistributable/x64/libNCSEcw.so
         #2  0x00007fffb2aa7727 in NCS::SDK::CBuffer2D::~CBuffer2D() () from /home/even/ecwjp2_sdk/redistributable/x64/libNCSEcw.so
--- a/frmts/gtiff/geotiff.cpp
+++ b/frmts/gtiff/geotiff.cpp
@@ -7470,14 +7470,14 @@ void GTiffDataset::WriteRPC( GDALDataset
             bRPCSerializedOtherWay = TRUE;
         }
 
-        /* Write RPB file if explicitely asked, or if a non GDAL specific */
+        /* Write RPB file if explicitly asked, or if a non GDAL specific */
         /* profile is selected and RPCTXT is not asked */
-        int bRPBExplicitelyAsked = CSLFetchBoolean( papszCreationOptions, "RPB", FALSE );
-        int bRPBExplicitelyDenied = !CSLFetchBoolean( papszCreationOptions, "RPB", TRUE );
+        int bRPBExplicitlyAsked = CSLFetchBoolean( papszCreationOptions, "RPB", FALSE );
+        int bRPBExplicitlyDenied = !CSLFetchBoolean( papszCreationOptions, "RPB", TRUE );
         if( (!EQUAL(pszProfile,"GDALGeoTIFF") && 
              !CSLFetchBoolean( papszCreationOptions, "RPCTXT", FALSE ) &&
-             !bRPBExplicitelyDenied )
-            || bRPBExplicitelyAsked )
+             !bRPBExplicitlyDenied )
+            || bRPBExplicitlyAsked )
         {
             if( !bWriteOnlyInPAMIfNeeded )
                 GDALWriteRPBFile( pszTIFFFilename, papszRPCMD );
--- a/frmts/l1b/l1bdataset.cpp
+++ b/frmts/l1b/l1bdataset.cpp
@@ -178,7 +178,7 @@ static const char *apszBandDesc[] =
 #define L1B_NOAA15_HDR_REC_SRC_OFF  154 // Receiving station name offset
 #define L1B_NOAA15_HDR_REC_ELLIPSOID_OFF 328
 
-/* This only apply if L1B_HIGH_GCP_DENSITY is explicitely set to NO */
+/* This only apply if L1B_HIGH_GCP_DENSITY is explicitly set to NO */
 /* otherwise we will report more GCPs */
 #define DESIRED_GCPS_PER_LINE 11
 #define DESIRED_LINES_OF_GCPS 20
--- a/frmts/openjpeg/openjpegdataset.cpp
+++ b/frmts/openjpeg/openjpegdataset.cpp
@@ -2484,7 +2484,7 @@ GDALDataset * JP2OpenJPEGDataset::Create
         !bGeoreferencingCompatOfGMLJP2 && nGMLJP2Version == 1 )
     {
         CPLError(CE_Warning, CPLE_AppDefined,
-                 "GMLJP2 box was explicitely required but cannot be written due "
+                 "GMLJP2 box was explicitly required but cannot be written due "
                  "to lack of georeferencing and/or unsupported georeferencing for GMLJP2");
     }
 
@@ -2492,7 +2492,7 @@ GDALDataset * JP2OpenJPEGDataset::Create
         !bGeoreferencingCompatOfGeoJP2 )
     {
         CPLError(CE_Warning, CPLE_AppDefined,
-                 "GeoJP2 box was explicitely required but cannot be written due "
+                 "GeoJP2 box was explicitly required but cannot be written due "
                  "to lack of georeferencing");
     }
     int bGeoBoxesAfter = CSLFetchBoolean(papszOptions, "GEOBOXES_AFTER_JP2C",
--- a/frmts/pdf/frmt_pdf.html
+++ b/frmts/pdf/frmt_pdf.html
@@ -108,7 +108,7 @@ specified, all features are rendered.</l
 Defaults to 3.</li>
 <li><i>GDAL_PDF_LAYERS</i> = list of layers (comma separated) to turn ON (or "ALL" to turn all layers ON).
 The layer names can be obtained by querying the LAYERS metadata domain. When this option is specified,
-layers not explicitely listed will be turned off.</li>
+layers not explicitly listed will be turned off.</li>
 <li><i>GDAL_PDF_LAYERS_OFF</i> = list of layers (comma separated) to turn OFF. The layer names can be obtained by
 querying the LAYERS metadata domain.</li>
 </ul>
--- a/gcore/gdaldllmain.cpp
+++ b/gcore/gdaldllmain.cpp
@@ -55,7 +55,7 @@ void CPLFinalizeTLS();
  * This function calls GDALDestroyDriverManager() and OGRCleanupAll() and
  * finalize Thread Local Storage variables.
  *
- * This function should *not* usually be explicitely called by application code
+ * This function should *not* usually be explicitly called by application code
  * if GDAL is dynamically linked, since it is automatically called through
  * the unregistration mechanisms of dynamic library loading.
  *
--- a/gcore/gdaldrivermanager.cpp
+++ b/gcore/gdaldrivermanager.cpp
@@ -435,7 +435,7 @@ int GDALDriverManager::RegisterDriver( G
         poDriver->SetMetadataItem( GDAL_DCAP_CREATECOPY, "YES" );
 
     /* Backward compability for GDAL raster out-of-tree drivers: */
-    /* if a driver hasn't explicitely set a vector capability, assume it is */
+    /* if a driver hasn't explicitly set a vector capability, assume it is */
     /* a raster driver (legacy OGR drivers will have DCAP_VECTOR set before */
     /* calling RegisterDriver() ) */
     if( poDriver->GetMetadataItem( GDAL_DCAP_RASTER ) == NULL &&
--- a/ogr/ogrcurvecollection.cpp
+++ b/ogr/ogrcurvecollection.cpp
@@ -315,7 +315,7 @@ OGRErr OGRCurveCollection::exportToWkb(
         if( nGType == wkbCurvePolygon )
             nGType = POSTGIS15_CURVEPOLYGON;
         if( bIs3D )
-            nGType = (OGRwkbGeometryType)(nGType | wkb25DBitInternalUse); /* yes we explicitely set wkb25DBit */
+            nGType = (OGRwkbGeometryType)(nGType | wkb25DBitInternalUse); /* yes we explicitly set wkb25DBit */
     }
 
     if( eByteOrder == wkbNDR )
--- a/ogr/ogrgeometrycollection.cpp
+++ b/ogr/ogrgeometrycollection.cpp
@@ -529,7 +529,7 @@ OGRErr  OGRGeometryCollection::exportToW
         else if( nGType == wkbMultiSurface )
             nGType = POSTGIS15_MULTISURFACE;
         if( bIs3D )
-            nGType = (OGRwkbGeometryType)(nGType | wkb25DBitInternalUse); /* yes we explicitely set wkb25DBit */
+            nGType = (OGRwkbGeometryType)(nGType | wkb25DBitInternalUse); /* yes we explicitly set wkb25DBit */
     }
     
     if( eByteOrder == wkbNDR )
--- a/ogr/ogrgeometryfactory.cpp
+++ b/ogr/ogrgeometryfactory.cpp
@@ -3485,8 +3485,8 @@ static int OGRGF_NeedSwithArcOrder(doubl
  *         and OGRGeometryFactory::curveFromLineString() can decode them.
  *         This is the best compromise for round-tripping in OGR and better results
  *         with PostGIS <a href="http://postgis.org/docs/ST_LineToCurve.html">ST_LineToCurve()</a>
- *         If set to YES, the intermediate point is explicitely added to the linestring.
- *         If set to NO, the intermediate point is not explicitely added.
+ *         If set to YES, the intermediate point is explicitly added to the linestring.
+ *         If set to NO, the intermediate point is not explicitly added.
  * </li>
  * </ul>
  *
--- a/ogr/ogrlinestring.cpp
+++ b/ogr/ogrlinestring.cpp
@@ -897,7 +897,7 @@ OGRErr  OGRSimpleCurve::exportToWkb( OGR
     if ( eWkbVariant == wkbVariantIso )
         nGType = getIsoGeometryType();
     else if( eWkbVariant == wkbVariantPostGIS1 && wkbHasZ((OGRwkbGeometryType)nGType) )
-        nGType = (OGRwkbGeometryType)(wkbFlatten(nGType) | wkb25DBitInternalUse); /* yes we explicitely set wkb25DBit */
+        nGType = (OGRwkbGeometryType)(wkbFlatten(nGType) | wkb25DBitInternalUse); /* yes we explicitly set wkb25DBit */
 
     if( eByteOrder == wkbNDR )
         nGType = CPL_LSBWORD32( nGType );
--- a/ogr/ogrsf_frmts/generic/ogrunionlayer.h
+++ b/ogr/ogrsf_frmts/generic/ogrunionlayer.h
@@ -112,7 +112,7 @@ class OGRUnionLayer : public OGRLayer
     void                SetFields(FieldUnionStrategy eFieldStrategy,
                                   int nFields,
                                   OGRFieldDefn** papoFields,  /* duplicated by the method */
-                                  int nGeomFields, /* maybe -1 to explicitely disable geometry fields */
+                                  int nGeomFields, /* maybe -1 to explicitly disable geometry fields */
                                   OGRUnionLayerGeomFieldDefn** papoGeomFields  /* duplicated by the method */);
     void                SetSourceLayerFieldName(const char* pszSourceLayerFieldName);
     void                SetPreserveSrcFID(int bPreserveSrcFID);
--- a/ogr/ogrsf_frmts/geojson/drv_geojson.html
+++ b/ogr/ogrsf_frmts/geojson/drv_geojson.html
@@ -28,7 +28,7 @@ And starting with OGR 2.0, the GeoJSON d
 are spread over multiple pages (for ArcGIS servers &gt;= 10.3). This is automatically enabled
 if URL does not contain an explicit <i>resultOffset</i> parameter. If it contains
 this parameter and scrolling is still desired, the FEATURE_SERVER_PAGING open option must be set to YES.
-The page size can be explicitely set with the <i>resultRecordCount</i> parameter (but
+The page size can be explicitly set with the <i>resultRecordCount</i> parameter (but
 is subject to a server limit). If it is not set, OGR will set it to the maximum
 value allowed by the server.</p>
 
--- a/ogr/ogrsf_frmts/gml/ogrgmldatasource.cpp
+++ b/ogr/ogrsf_frmts/gml/ogrgmldatasource.cpp
@@ -1421,7 +1421,7 @@ OGRGMLLayer *OGRGMLDataSource::Translate
         }
     }
 
-    /* Report a COMPD_CS only if GML_REPORT_COMPD_CS is explicitely set to TRUE */
+    /* Report a COMPD_CS only if GML_REPORT_COMPD_CS is explicitly set to TRUE */
     if( poSRS != NULL &&
         !CSLTestBoolean(CPLGetConfigOption("GML_REPORT_COMPD_CS", "FALSE")) )
     {
--- a/ogr/ogrsf_frmts/gpkg/drv_geopackage_raster.html
+++ b/ogr/ogrsf_frmts/gpkg/drv_geopackage_raster.html
@@ -124,7 +124,7 @@ recompression of tiles to be done, which
 lossy compression (JPEG, WebP). To avoid that, the driver will create a temporary
 database next to the main GeoPackage file to store partial GeoPackage tiles in a
 lossless (and uncompressed) way. Once a tile has received data for its four quadrants
-and for all the bands (or the dataset is closed or explicitely flushed with FlushCache()),
+and for all the bands (or the dataset is closed or explicitly flushed with FlushCache()),
 those uncompressed tiles are definitely transfered to the GeoPackage file with
 the appropriate compression. All of this is transparent to the user of GDAL API/utilities</p>
 
--- a/ogr/ogrsf_frmts/pg/ogrpglayer.cpp
+++ b/ogr/ogrsf_frmts/pg/ogrpglayer.cpp
@@ -1509,7 +1509,7 @@ OGRFeature *OGRPGLayer::GetNextRawFeatur
     {
         CPLError(CE_Failure, CPLE_AppDefined,
                  "Cursor used to read layer has been closed due to a COMMIT. "
-                 "ResetReading() must be explicitely called to restart reading");
+                 "ResetReading() must be explicitly called to restart reading");
         return NULL;
     }
     
--- a/ogr/ogrsf_frmts/vrt/ogrvrtlayer.cpp
+++ b/ogr/ogrsf_frmts/vrt/ogrvrtlayer.cpp
@@ -409,7 +409,7 @@ int OGRVRTLayer::ParseGeometryField(CPLX
         CSLTestBoolean(CPLGetXMLValue( psNode, "reportSrcColumn", "YES" ));
 
 /* -------------------------------------------------------------------- */
-/*      Guess geometry type if not explicitely provided (or computed)   */
+/*      Guess geometry type if not explicitly provided (or computed)   */
 /* -------------------------------------------------------------------- */
     if( pszGType == NULL && poProps->eGeomType == wkbUnknown )
     {
@@ -2322,7 +2322,7 @@ OGRErr OGRVRTLayer::SetIgnoredFields( co
     char** papszFieldsSrc = NULL;
     OGRFeatureDefn* poSrcFeatureDefn = poSrcLayer->GetLayerDefn();
 
-    /* Translate explicitely ignored fields of VRT layers to their equivalent */
+    /* Translate explicitly ignored fields of VRT layers to their equivalent */
     /* source fields. */
     while ( papszIter != NULL && *papszIter != NULL )
     {
--- a/port/cpl_virtualmem.cpp
+++ b/port/cpl_virtualmem.cpp
@@ -626,7 +626,7 @@ static void CPLVirtualMemSIGUSR1Handler(
     /* I guess this is only POSIX correct if it is implemented by an intrinsic */
     CPLAtomicInc(&nCountThreadsInSigUSR1);
     while( nWaitHelperThread )
-        usleep(1); /* not explicitely indicated as signal-async-safe, but hopefully ok */
+        usleep(1); /* not explicitly indicated as signal-async-safe, but hopefully ok */
     CPLAtomicDec(&nCountThreadsInSigUSR1);
     /* fprintfstderr("leaving CPLVirtualMemSIGUSR1Handler %X\n", pthread_self()); */
 }
